# 在文件中移动

一开始, 通过键盘移动会让你感觉特别慢特别不自在, 但是不要放弃! 一旦你习惯了它, 比起鼠标你可以在文件中更快的去到任何地方.

这一章, 你将学习必要的移动以及如何高效的使用它们, 记住, 这一章所讲的并不是Vim的全部移动命令, 我们的目标是介绍有用的移动来快速提高生产力. 如果你需要学习更多的移动命令, 查看`:h motion.txt`.

# 字符导航

最基本的移动单元是上下左右移动一个字符.
```
h   左
j   下
k   上
l   右
```
你也可以通过方向键进行移动, 如果你只是初学者, 使用任何你觉得最舒服的方法都没有关系.

我更喜欢`hjkl`因为我的右手可以保持在键盘上的默认姿势, 这样做可以让我更快的敲周围的键. 为了习惯它, 我实际上在刚开始的时候通过`~/.vimrc`关闭了方向键:
```
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```
也有一些插件可以帮助改掉这个坏习惯, 其中有一个叫[vim-hardtime](https://github.com/takac/vim-hardtime). 让我感到惊讶的是, 我只用了几天就习惯了使用`hjkl`.

另外, 如果你想知道为什么vim使用`hjkl`进行移动, *这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键, 而是把`hjkl`当做方向键*.

如果你想移动到附近的某个地方, 比如从一个单词的一个部分移动到另一个部分, 我会使用`h`和`l`. 如果我需要在可见的范围内上下移动几行, 我会使用`j`和`k`. 如果我向去更远的地方, 我倾向于使用其他移动命令.

# 相对行号

我觉得设置`number`和`relativenumber`非常有用, 你可以在`~/.vimrc`中设置:
```
set relativenumber number
```
这将会展示我的当前行号和其他行相对我的行号.

为什么这个功能有用呢? 者这个功能能够帮助我知道我离我的目标位置差了多少行, 有了它我可以很轻松的知道我的目标行在我下方12行, 因此我可以使用`12j`去前往. 否则, 如果我在69行, 我的目标是81行, 我需要去计算81-69=12行, 这太花费脑子了. 当我需要去一个地方时, 我需要动脑子的部分越少越好.

这个是100%的个人偏好, 你可以尝试`relativenumber`/`norelativenumber`, `number`/`nonumber` 然后选择自己觉得最有用的.

# 对你的移动计数

还有一件事情, 让我们讨论一下"计数"参数, 移动可以接受一个数字前缀作为参数, 上面我提到的你可以通过`12j`向下移动12行, 其中`12j`中的12就是计数数字.

你使用带计数的移动的语法如下:
```
[计数] + 移动
```
你可以把这个应用到所有移动上, 如果你想向右移动9个字符, 你可以使用`9l`来代替按9次`l`. 当你学到了更多的动作时, 你都可以试试给定计数参数.

# 单词导航

我们现在移动一个更长的单元:单词(word). 你可以通过`w`移动到下一个单词的开始, 通过`e`移动到下一个单词的结尾, 通过`b`移动到上一个单词的开始, 通过`ge`移动到前一个单词的结尾.

另外, 为了和上面说的单词(word)做个区分, 还有一种移动的单元:词组(WORD). 你可以通过`W`移动到下一个单词的开始, 通过`E`移动到下一个单词的结尾, 通过`B`移动到前一个单词的开头, 通过`gE`移动到上一个单词的结尾. 为了方便记忆, 所以选择了我们选择了词组和单词这两个词, 相似但有些区分.

```
w   移动到下一个单词的开头
W   移动到下一个词组的开头
e   移动到下一个单词的结尾
E   移动到下一个词组的结尾
b   移动到前一个单词的开头
B   移动到前一个词组的开头
ge  移动到前一个单词的结尾
gE  移动到前一个词组的结尾
```

那么, 词组和单词有什么相同和不同呢? 单词和词组都按照非空字符被分割, 一个单词指的是一个只包含`a-zA-Z0-9`字符串, 一个词组指的是一个包含除了空字符(包括空格,tab, EOL)以外的字符的字符串. 你可以通过`:h word`和`:h WORD`了解更多.

例如, 假如你有下面这段内容:
```
const hello = "world";
```
当你光标位于这行的开头时, 你可以通过`l`走到行尾, 但是你需要按21下, 使用`w`, 你需要6下, 使用`W`只需要4下. 单词和词组都是短距离移动的很好的选择.

然而, 你可以通过当前行导航只按一次从`c`移动到`;`

# 当前行导航

当你在进行编辑的时候, 你经常需要水平地在一行中移动, 你可以通过`0`跳到本行第一个字符, 通过`$`跳到本行最后一个字符. 另外, 你可以使用`^`跳到本行第一个非空字符, 通过`g_`跳到本行最后一个非空字符. 如果你想去当前行的第n列, 你可以使用`n|`.

```
0   跳到本行第一个字符
^   跳到本行第一个非空字符
g_  跳到本行最后一个非空字符
$   跳到本行最后一个字符
n|  跳到本行第n列
```

你也可以在本行通过`f`和`t`进行行内搜索, `f`和`t`的区别在于`f`会停在第一个匹配的字母上, `t`会停在第一个匹配的字母前. 因此如果你想要搜索并停留在"h"上, 使用`fh`. 如果你想搜索第一个"h"并停留在它的前一个字母上, 可以使用`th`. 如果你想去下一个行内匹配的位置, 使用`;`, 如果你想去前一个行内匹配的位置, 使用`,`.

如果想向前搜索"h", 可以使用`Fh`, 使用`;`, 保持相同的搜索方向搜索下一个匹配的字母. 注意, `;`不是总是向后搜索, `;`表示的是上一次搜索的方向, 因此如果你使用的`F`, 那么使用`;`时将会向前搜索使用`,`时向后搜索.

```
f   在同一行向后搜索第一个匹配
F   在同一行向前搜索第一个匹配
t   在同一行向后搜索第一个匹配, 并停在匹配前
T   在同一行向前搜索第一个匹配, 并停在匹配前
;   在同一行重复最近一次搜索
,   在同一行向相反方向重复最近一次搜索
```

回到上一个例子:

```
const hello = "world";
```
当你的光标位于行的开头时, 你可以通过按一次键`$`去往行尾的最后一个字符";". 如果想去往"world"中的"w", 你可以使用`fw`. 一个好的建议是, 在行内目标附近通过寻找重复出现最少的字母例如"j", "x", "z"来前往行中的任何位置.

# 句子和段落导航

接下来两个移动的单元是句子和段落.

首先我们来聊聊句子. 一个句子的定义是以`.!?`和跟着的一个换行符 或空格, tab结尾的. 你可以通过`)`和`(`跳到下一个和上一个句子.

```
(   跳到前一个句子
)   跳到下一个句子
```

让我们来看一些例子, 你觉得哪些字段是句子哪些不是? 看尝试在Vim中用`(`和`)`感受一下.
```
I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :

There is an empty line above me.
```
另外, 如果你的Vim中遇到了无法将一个以`.`结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题, 你可能处于`compatible`的模式. 运行`:set nocompatible`可以修复. 在Vi中,一个句子是以**两个**空格结尾的, 你应该总是保持的`nocompatible`的设置.

接下来, 我们将讨论什么是段落. 一个段落从一个空行之后开始, 也从段落选项中字符对所指定的段落宏的每个集合开始.

```
{   跳转到上一个段落
}   跳转到下一个段落
```

如果你不知道什么是段落宏, 不用担心, 重要的是一个段落总是以一个空行开始和结尾, 在大多数时候总是对的.

我们来看这个例子. 你可以尝试着使用`}`和`{`进行导航, 也可以玩一玩`()`这样的句子导航.
```
Hello. How are you? I am great, thanks!
Vim is awesome.
It may not easy to learn it at first...- but we are in this together. Good luck!

Hello again.

Try to move around with ), (, }, and {. Feel how they work.
You got this.
```

你可以通过`:h setence`和`:h paragraph`了解更多.

# 匹配导航

程序员经常编辑含有代码的文件, 这种文件内容会包含大量的小括号, 中括号和大括号, 并且可能会把你搞迷糊你当前到底在哪对括号里. 许多编程语言都用到了小括号, 中括号和大括号, 你可能会迷失于其中. 如果你在它们中的某一对括号中, 你可以通过`%`跳到q其中一个括号或另一个上(如果存在). 你也可以通过这种方法弄清你是否各个括号都成对匹配了.
```
%    Navigate to another match, usually works for (), [], {}
```

我们来看一段Scheme代码示例因为它用了大量的小括号. 你可以在括号中用`%`移动

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```
我个人喜欢使用类似[vim-rainbow](https://github.com/frazrepo/vim-rainbow)这样的可视化指示插件来作为`%`的补充. 通过`:h %`了解更多.

# 行号导航


